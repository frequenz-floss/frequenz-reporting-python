{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Reporting Highlevel Interface","text":""},{"location":"#introduction","title":"Introduction","text":"<p>A highlevel interface for the reporting API</p>"},{"location":"#supported-platforms","title":"Supported Platforms","text":"<p>The following platforms are officially supported (tested):</p> <ul> <li>Python: 3.11</li> <li>Operating System: Ubuntu Linux 20.04</li> <li>Architectures: amd64, arm64</li> </ul>"},{"location":"#contributing","title":"Contributing","text":"<p>If you want to know how to build this project and contribute to it, please check out the Contributing Guide.</p>"},{"location":"#installation","title":"Installation","text":"<pre><code># Choose the version you want to install\nVERSION=0.1.0\npip install frequenz-reporting-python==$VERSION\n</code></pre>"},{"location":"#initialize-the-client","title":"Initialize the client","text":"<pre><code>from datetime import datetime\n\nfrom frequenz.client.common.metric import Metric\nfrom frequenz.client.reporting import ReportingApiClient\nfrom frequenz.reporting._reporting import cumulative_energy\n\n# Change server address if needed\nSERVICE_ADDRESS = \"reporting.api.frequenz.com:443\"\nAPI_KEY = open('api_key.txt').read().strip()\nclient = ReportingApiClient(service_address=SERVICE_ADDRESS, key=API_KEY)\n</code></pre>"},{"location":"#calculate-cumulative-energy-for-a-single-microgrid-and-component","title":"Calculate cumulative energy for a single microgrid and component:","text":"<p>If the component does not measure <code>Metric.AC_ACTIVE_ENERGY</code>, set <code>use_active_power=True</code> to utilize <code>Metric.AC_ACTIVE_POWER</code> instead.</p> <p>A resolution can be set that alters how NaNs are handled, resulting in varying results. NaN values are ignored in sums, which may lead to significant data loss if many are present in the raw data. There is no universally correct method for handling NaNs, as their causes can vary.</p> <pre><code>energy_reading = await cumulative_energy(\n            client=client,\n                        microgrid_id=1,\n                        component_id=100,\n                        start_time=datetime.fromisoformat(\"2024-09-01T00:00:00\"),\n                        end_time=datetime.fromisoformat(\"2024-09-30T00:00:00\"),\n                        use_active_power=True,\n                        resolution=10,\n    )\n\nprint(energy_reading)\n</code></pre>"},{"location":"CONTRIBUTING/","title":"Contributing to Reporting Highlevel Interface","text":""},{"location":"CONTRIBUTING/#build","title":"Build","text":"<p>You can use <code>build</code> to simply build the source and binary distribution:</p> <pre><code>python -m pip install build\npython -m build\n</code></pre>"},{"location":"CONTRIBUTING/#local-development","title":"Local development","text":"<p>You can use editable installs to develop the project locally (it will install all the dependencies too):</p> <pre><code>python -m pip install -e .\n</code></pre> <p>Or you can install all development dependencies (<code>mypy</code>, <code>pylint</code>, <code>pytest</code>, etc.) in one go too: <pre><code>python -m pip install -e .[dev]\n</code></pre></p> <p>If you don't want to install all the dependencies, you can also use <code>nox</code> to run the tests and other checks creating its own virtual environments:</p> <pre><code>python -m pip install .[dev-noxfile]\nnox\n</code></pre> <p>You can also use <code>nox -R</code> to reuse the current testing environment to speed up test at the expense of a higher chance to end up with a dirty test environment.</p>"},{"location":"CONTRIBUTING/#running-tests-checks-individually","title":"Running tests / checks individually","text":"<p>For a better development test cycle you can install the runtime and test dependencies and run <code>pytest</code> manually.</p> <pre><code>python -m pip install .[dev-pytest]  # included in .[dev] too\n\n# And for example\npytest tests/test_*.py\n</code></pre> <p>Or you can use <code>nox</code>:</p> <pre><code>nox -R -s pytest -- test/test_*.py\n</code></pre> <p>The same appliest to <code>pylint</code> or <code>mypy</code> for example:</p> <pre><code>nox -R -s pylint -- test/test_*.py\nnox -R -s mypy -- test/test_*.py\n</code></pre>"},{"location":"CONTRIBUTING/#building-the-documentation","title":"Building the documentation","text":"<p>To build the documentation, first install the dependencies (if you didn't install all <code>dev</code> dependencies):</p> <pre><code>python -m pip install -e .[dev-mkdocs]\n</code></pre> <p>Then you can build the documentation (it will be written in the <code>site/</code> directory):</p> <pre><code>mkdocs build\n</code></pre> <p>Or you can just serve the documentation without building it using:</p> <pre><code>mkdocs serve\n</code></pre> <p>Your site will be updated live when you change your files (provided that you used <code>pip install -e .</code>, beware of a common pitfall of using <code>pip install</code> without <code>-e</code>, in that case the API reference won't change unless you do a new <code>pip install</code>).</p> <p>To build multi-version documentation, we use mike. If you want to see how the multi-version sites looks like locally, you can use:</p> <pre><code>mike deploy my-version\nmike set-default my-version\nmike serve\n</code></pre> <p><code>mike</code> works in mysterious ways. Some basic information:</p> <ul> <li><code>mike deploy</code> will do a <code>mike build</code> and write the results to your local <code>gh-pages</code> branch. <code>my-version</code> is an arbitrary name for the local version   you want to preview.</li> <li><code>mike set-default</code> is needed so when you serve the documentation, it goes to   your newly produced documentation by default.</li> <li><code>mike serve</code> will serve the contents of your local <code>gh-pages</code> branch. Be   aware that, unlike <code>mkdocs serve</code>, changes to the sources won't be shown   live, as the <code>mike deploy</code> step is needed to refresh them.</li> </ul> <p>Be careful not to use <code>--push</code> with <code>mike deploy</code>, otherwise it will push your local <code>gh-pages</code> branch to the <code>origin</code> remote.</p> <p>That said, if you want to test the actual website in your fork, you can always use <code>mike deploy --push --remote your-fork-remote</code>, and then access the GitHub pages produced for your fork.</p>"},{"location":"CONTRIBUTING/#releasing","title":"Releasing","text":"<p>These are the steps to create a new release:</p> <ol> <li> <p>Get the latest head you want to create a release from.</p> </li> <li> <p>Update the <code>RELEASE_NOTES.md</code> file if it is not complete, up to date, and    remove template comments (<code>&lt;!-- ... -&gt;</code>) and empty sections. Submit a pull    request if an update is needed, wait until it is merged, and update the    latest head you want to create a release from to get the new merged pull    request.</p> </li> <li> <p>Create a new signed tag using the release notes and    a semver compatible version number with a <code>v</code> prefix,    for example:</p> </li> </ol> <pre><code>git tag -s --cleanup=whitespace -F RELEASE_NOTES.md v0.0.1\n</code></pre> <ol> <li> <p>Push the new tag.</p> </li> <li> <p>A GitHub action will test the tag and if all goes well it will create    a GitHub    Release,    and upload a new package to    PyPI    automatically.</p> </li> <li> <p>Once this is done, reset the <code>RELEASE_NOTES.md</code> with the template:</p> </li> </ol> <pre><code>cp .github/RELEASE_NOTES.template.md RELEASE_NOTES.md\n</code></pre> <p>Commit the new release notes and create a PR (this step should be automated    eventually too).</p> <ol> <li>Celebrate!</li> </ol>"},{"location":"CONTRIBUTING/#cross-arch-testing","title":"Cross-Arch Testing","text":"<p>This project has built-in support for testing across multiple architectures. Currently, our CI conducts tests on <code>arm64</code> machines using QEMU emulation. We also have the flexibility to expand this support to include additional architectures in the future.</p> <p>This project contains Dockerfiles that can be used in the CI to test the python package in non-native machine architectures, e.g., <code>arm64</code>. The Dockerfiles exist in the directory <code>.github/containers/nox-cross-arch</code>, and follow a naming scheme so that they can be easily used in build matrices in the CI, in <code>nox-cross-arch</code> job. The naming scheme is:</p> <pre><code>&lt;arch&gt;-&lt;os&gt;-python-&lt;python-version&gt;.Dockerfile\n</code></pre> <p>E.g.,</p> <pre><code>arm64-ubuntu-20.04-python-3.11.Dockerfile\n</code></pre> <p>If a Dockerfile for your desired target architecture, OS, and python version does not exist here, please add one before proceeding to add your options to the test matrix.</p>"},{"location":"SUMMARY/","title":"SUMMARY","text":"<ul> <li>Home</li> <li>API Reference</li> <li>Contributing</li> </ul>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>frequenz<ul> <li>reporting</li> </ul> </li> </ul>"},{"location":"reference/frequenz/reporting/","title":"reporting","text":""},{"location":"reference/frequenz/reporting/#frequenz.reporting","title":"frequenz.reporting","text":"<p>A highlevel interface for the reporting API.</p>"},{"location":"reference/frequenz/reporting/#frequenz.reporting-functions","title":"Functions","text":""},{"location":"reference/frequenz/reporting/#frequenz.reporting.delete_me","title":"frequenz.reporting.delete_me","text":"<pre><code>delete_me(*, blow_up: bool = False) -&gt; bool\n</code></pre> <p>Do stuff for demonstration purposes.</p> PARAMETER DESCRIPTION <code>blow_up</code> <p>If True, raise an exception.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>True if no exception was raised.</p> RAISES DESCRIPTION <code>RuntimeError</code> <p>if blow_up is True.</p> Source code in <code>frequenz/reporting/__init__.py</code> <pre><code>def delete_me(*, blow_up: bool = False) -&gt; bool:\n    \"\"\"Do stuff for demonstration purposes.\n\n    Args:\n        blow_up: If True, raise an exception.\n\n    Returns:\n        True if no exception was raised.\n\n    Raises:\n        RuntimeError: if blow_up is True.\n    \"\"\"\n    if blow_up:\n        raise RuntimeError(\"This function should be removed!\")\n    return True\n</code></pre>"}]}